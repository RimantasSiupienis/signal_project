Alert Generation System:

This subsystem handles how alerts are triggered based on patient data. The central class is AlertGenerator, which uses DataStorage to access all patient data and holds a list of AlertStrategy implementations. It provides methods to evaluate data for all patients (evaluateAll) or just one (evaluateData). When conditions are met, it uses triggerAlert to create an Alert object. The Alert class stores alert-specific information like patient ID, condition, and timestamp. All triggered alerts are stored in a list and can be accessed using getTriggeredAlerts. Patient data is retrieved through DataStorage, which provides access to Patient objects, each of which holds PatientRecords. The Patient class provides getPatientId, addRecord, and getRecords methods to manage time-based data. The AlertManager class contains a dispatch method, which represents how alerts could be forwarded or handled after creation. This setup allows alerts to be triggered based on specific conditions defined in strategies, keeping data evaluation and alert creation modular and organized.

Patient Identification System:

This subsystem connects patient data to hospital records. At the center is PatientIdentifier, which maintains a patientList array and a Map<Patient, HospitalPatient>. The method matchRecords is used to associate hospital data with existing patients, while getRecords retrieves the corresponding HospitalPatient. The HospitalPatient class stores personal information like names, patient age, and patient history. It provides access to specific parts of that data via methods such as getHistory, getNames, and getAge. The Patient class represents a patient and their data. It stores the patient’s ID and a list of PatientRecord objects. It also holds a reference to a HospitalPatient, which can be set and retrieved using setHospitalPatient and getHospitalPatient. The patient’s data can be updated using addRecord and retrieved using getRecords with a time range. This design maps patients in the system to their hospital profiles and provides access to relevant history and data.

Data Access Layer:

This subsystem handles how data from external sources is received and passed into the system. The central class is DataListener, which defines the method readData(DataStorage). It is extended by WebSocketDataListener, FileDataListener, and TCPDataListener, each implementing the listener for a specific data source. Input data is processed by DataParser, which contains the method parse(rawInput) and converts raw strings into a list of PatientRecord objects. These records are passed to the DataSourceAdapter, which defines sendToStorage(PatientRecord) and sends the structured data to storage. DataStorage contains both the DataParser and DataSourceAdapter, and acts as the entry point for the listeners. This setup allows the system to support multiple input formats and keep parsing and storage responsibilities separated. It enables clean integration between the external environment and the internal system logic.

Data Storage System:

This subsystem handles how patient data is stored and retrieved. The central class is DataStorage, which stores both the DataParser and DataSourceAdapter. It provides two main methods for external access: getRecords(patientId, startTime, endTime) and getAllPatients(). Patient data is stored in instances of the Patient class, each of which maintains a list of PatientRecord objects and a patient ID. The Patient class includes methods for adding records (addRecord) and retrieving them over time ranges (getRecords). The Patient class also references a HospitalPatient, which can be set and accessed using setHospitalPatient and getHospitalPatient. Each PatientRecord stores a patient ID, record type, measurement value, and timestamp, and offers getter methods for each. This setup allows for structured access to all patient data collected by the system. It supports time-based querying and integration with parsing and input adapters, and it serves as a central source of truth for signal data in the system.
